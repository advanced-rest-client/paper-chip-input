<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>paper-chip-input test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

</head>
<body>
  <test-fixture id="Basic">
    <template>
      <paper-chip-input></paper-chip-input>
    </template>
  </test-fixture>

  <test-fixture id="BasicRequired">
    <template>
      <paper-chip-input required></paper-chip-input>
    </template>
  </test-fixture>

  <test-fixture id="Pattern">
    <template>
      <paper-chip-input pattern="[a-zA-Z]+"></paper-chip-input>
    </template>
  </test-fixture>

  <test-fixture id="Chips">
    <template>
      <paper-chip-input chips='[{"label": "c-1"}, {"label": "c-2", "removable": true}, {"label": "c-3"}]'></paper-chip-input>
    </template>
  </test-fixture>

  <test-fixture id="NoRemove">
    <template>
      <paper-chip-input chips='[{"label": "c-1"}, {"label": "c-2"}, {"label": "c-3"}]'></paper-chip-input>
    </template>
  </test-fixture>

  <test-fixture id="AllRemove">
    <template>
      <paper-chip-input chips='[{"label": "c-1", "removable": true}, {"label": "c-2", "removable": true}, {"label": "c-3", "removable": true}]'></paper-chip-input>
    </template>
  </test-fixture>

  <test-fixture id="Allowed">
    <template>
      <paper-chip-input allowed='["c1", "c2", "c-3"]'></paper-chip-input>
    </template>
  </test-fixture>

  <test-fixture id="Suggestions">
    <template>
      <paper-chip-input source='["c1", "c2", "c-3"]'></paper-chip-input>
    </template>
  </test-fixture>

  <test-fixture id="SuggestionsWithIcons">
    <template>
      <paper-chip-input source='[{"value":"c1","icon":"i1"}, {"value":"c2","icon":"i2"}, {"value":"c3","icon":"i3"}]'></paper-chip-input>
    </template>
  </test-fixture>

  <script type="module">
  import '../../../@polymer/iron-icons/iron-icons.js';
  import '../paper-chip-input.js';
  import sinon from '../../../sinon/pkg/sinon-esm.js';
  suite('Basics', () => {
    let element;

    test('_positionTarget is set', (done) => {
      element = fixture('Basic');
      flush(() => {
        assert.ok(element._positionTarget);
        assert.equal(element._positionTarget.nodeName, 'IRON-INPUT');
        done();
      });
    });
  });

  suite('Adding a chip', () => {
    let element;

    test('Value is initially undefined', () => {
      element = fixture('Basic');
      assert.isUndefined(element.value);
    });

    test('Accepts chip from value', (done) => {
      element = fixture('Basic');
      element._value = 'test';
      flush(() => {
        element._enterHandler();
        assert.typeOf(element.value, 'array');
        assert.lengthOf(element.value, 1);
        assert.equal(element.value[0], 'test');
        done();
      });
    });

    test('Ignores empty values', (done) => {
      element = fixture('Basic');
      element._value = '';
      flush(() => {
        element._enterHandler();
        assert.isUndefined(element.value, 'array');
        done();
      });
    });

    test('Clears input value after accepting input', (done) => {
      element = fixture('Basic');
      element._value = 'test';
      flush(() => {
        element._enterHandler();
        assert.equal(element._value, '');
        done();
      });
    });

    test('Ignores existing value', (done) => {
      element = fixture('Chips');
      flush(() => {
        element._value = 'c-1';
        element._enterHandler();
        assert.typeOf(element.value, 'array');
        assert.lengthOf(element.value, 3);
        done();
      });
    });

    test('Clears input value after ignoring it', (done) => {
      element = fixture('Chips');
      flush(() => {
        element._value = 'c-1';
        element._enterHandler();
        assert.equal(element._value, '');
        done();
      });
    });

    test('Allows only "allowed" chips (by value)', (done) => {
      element = fixture('Allowed');
      flush(() => {
        element._value = 'c1';
        element._enterHandler();
        assert.equal(element._value, '');
        done();
      });
    });

    test('Ignores values not defined in "allowed" (by value)', (done) => {
      element = fixture('Allowed');
      flush(() => {
        element._value = 'c1';
        element._enterHandler();
        assert.typeOf(element.value, 'array');
        assert.equal(element.value[0], 'c1');
        done();
      });
    });

    test('Allows only "allowed" chips (by id)', (done) => {
      element = fixture('Allowed');
      element.source = [{value: 'c1 label', id: 'c1'}];
      flush(() => {
        element._value = 'c1 label';
        element._suggestionsOpened = false;
        element._enterHandler();
        assert.typeOf(element.value, 'array');
        assert.equal(element.value[0], 'c1');
        done();
      });
    });

    test('Ignores values not defined in "allowed" (by id)', (done) => {
      element = fixture('Allowed');
      element.source = [{value: 'c1 label', id: 'c-not-allowed'}];
      flush(() => {
        element._value = 'c1 label';
        element._suggestionsOpened = false;
        element._enterHandler();
        assert.isUndefined(element.value, 'array');
        done();
      });
    });
  });

  suite('Removing a chip', () => {
    let element;
    test('Does nothing when no input and no chips', (done) => {
      element = fixture('Basic');
      flush(() => {
        element._backspaceHandler();
        // no errors recorded
        done();
      });
    });

    test('Do not remove chips when input has text', (done) => {
      element = fixture('AllRemove');
      element._value = 'test';
      flush(() => {
        element._backspaceHandler();
        assert.typeOf(element.value, 'array');
        assert.lengthOf(element.value, 3);
        done();
      });
    });

    test('Removes the chip when input is empty', (done) => {
      element = fixture('AllRemove');
      flush(() => {
        element._backspaceHandler();
        assert.typeOf(element.value, 'array');
        assert.lengthOf(element.value, 2);
        assert.deepEqual(element.value, ['c-1', 'c-2']);
        done();
      });
    });

    test('Removes only removable chips', (done) => {
      element = fixture('Chips');
      flush(() => {
        element._backspaceHandler();
        assert.typeOf(element.value, 'array');
        assert.lengthOf(element.value, 2);
        assert.deepEqual(element.value, ['c-1', 'c-3']);
        done();
      });
    });

    test('Enters chip label into the input field', (done) => {
      element = fixture('AllRemove');
      flush(() => {
        element._backspaceHandler();
        setTimeout(() => {
          assert.equal(element._value, 'c-3');
          done();
        }, 10);
      });
    });

    test('Handles remove event', (done) => {
      element = fixture('Chips');
      flush(() => {
        const node = element.shadowRoot.querySelectorAll('paper-chip')[1];
        node.dispatchEvent(new CustomEvent('chip-removed', {
          composed: true
        }));
        assert.typeOf(element.value, 'array');
        assert.lengthOf(element.value, 2);
        assert.deepEqual(element.value, ['c-1', 'c-3']);
        done();
      });
    });
  });

  suite('Allowed chips', () => {
    let element;
    setup((done) => {
      element = fixture('Allowed');
      flush(() => done());
    });

    test('Accepts allowed value', () => {
      element._value = 'c1';
      element._enterHandler();
      assert.equal(element.value[0], 'c1');
    });

    test('Ignores unknown value', () => {
      element._value = 'unknown';
      element._enterHandler();
      assert.isUndefined(element.value);
    });
  });

  suite('Auto suggestions', () => {
    let element;
    setup((done) => {
      element = fixture('Suggestions');
      flush(() => done());
    });

    test('Opens suggestions dropdown', () => {
      element._value = 'c';
      const node = element.shadowRoot.querySelector('paper-chip-autocomplete');
      assert.isTrue(node.opened);
    });

    test('Does no open suggestions when filtered empty', () => {
      element._value = 'cz';
      const node = element.shadowRoot.querySelector('paper-chip-autocomplete');
      assert.isFalse(node.opened);
    });

    test('Ignores enter when suggestions are opened', () => {
      element._value = 'c';
      element._enterHandler();
      assert.equal(element._value, 'c');
      assert.isUndefined(element.value);
    });

    test('Accepts suggestion', (done) => {
      element._value = 'c';
      flush(() => {
        const node = element.shadowRoot.querySelector('paper-chip-autocomplete');
        node.dispatchEvent(new CustomEvent('selected', {
          composed: true,
          detail: {
            value: {
              value: 'c1'
            }
          }
        }));
        assert.equal(element._value, '');
        assert.equal(element.value[0], 'c1');
        done();
      });
    });

    test('Accepts suggestion and an icon', (done) => {
      element._value = 'c';
      flush(() => {
        const node = element.shadowRoot.querySelector('paper-chip-autocomplete');
        node.dispatchEvent(new CustomEvent('selected', {
          composed: true,
          detail: {
            value: {
              value: 'c1',
              icon: 'test'
            }
          }
        }));
        flush(() => {
          const node = element.shadowRoot.querySelector('paper-chip iron-icon');
          assert.equal(node.icon, 'test');
          done();
        });
      });
    });
  });

  suite('Value computation', () => {
    let element;

    test('Creates chips from value', () => {
      element = fixture('Basic');
      element.value = ['test1', 'test2'];
      assert.typeOf(element.chips, 'array');
      assert.lengthOf(element.chips, 2);
    });

    test('Created chip is removable', () => {
      element = fixture('Basic');
      element.value = ['test1'];
      assert.isTrue(element.chips[0].removable);
    });

    test('Created chip has label from value', () => {
      element = fixture('Basic');
      element.value = ['test1'];
      assert.equal(element.chips[0].label, 'test1');
    });

    test('Value is unchanged', () => {
      element = fixture('Basic');
      element.value = ['test1'];
      assert.deepEqual(element.value, ['test1']);
    });

    test('Uses suggestions to render chips', () => {
      element = fixture('SuggestionsWithIcons');
      element.value = ['c2'];
      assert.equal(element.chips[0].label, 'c2', 'Has label');
      assert.isTrue(element.chips[0].removable, 'Is removable');
      assert.equal(element.chips[0].icon, 'i2', 'Has icon');
    });

    test('Removes chips when value is empty array', (done) => {
      element = fixture('Basic');
      element.value = ['test1', 'test2'];
      flush(() => {
        element.value = [];
        assert.lengthOf(element.chips, 0);
        done();
      });
    });

    test('Removes chips when value is undefined', (done) => {
      element = fixture('Basic');
      element.value = ['test1', 'test2'];
      flush(() => {
        element.value = undefined;
        assert.lengthOf(element.chips, 0);
        done();
      });
    });
  });

  suite('_chipFocused()', () => {
    let element;
    let ev;
    setup((done) => {
      element = fixture('Basic');
      ev = {
        preventDefault: () => {},
        stopPropagation: () => {},
        stopImmediatePropagation: () => {}
      };
      flush(() => done());
    });

    test('Prevents default', () => {
      const spy = sinon.spy(ev, 'preventDefault');
      element._chipFocused(ev);
      assert.isTrue(spy.called);
    });

    test('Stops propagation', () => {
      const spy = sinon.spy(ev, 'stopPropagation');
      element._chipFocused(ev);
      assert.isTrue(spy.called);
    });

    test('Stops propagation on element', () => {
      const spy = sinon.spy(ev, 'stopImmediatePropagation');
      element._chipFocused(ev);
      assert.isTrue(spy.called);
    });
  });

  suite('_inputBlur()', () => {
    let element;
    setup((done) => {
      element = fixture('Basic');
      flush(() => done());
    });

    test('Calls _enterHandler() when value', () => {
      element._value = 'test';
      const spy = sinon.spy(element, '_enterHandler');
      element._inputBlur();
      assert.isTrue(spy.called);
    });

    test('Won\'t call _enterHandler() when no value', () => {
      element._value = '';
      const spy = sinon.spy(element, '_enterHandler');
      element._inputBlur();
      assert.isFalse(spy.called);
    });
  });

  suite('validate()', () => {
    test('Returns true when no chips', (done) => {
      const element = fixture('Basic');
      flush(() => {
        const result = element.validate();
        assert.isTrue(result);
        done();
      });
    });

    test('Returns false when no chips and required', (done) => {
      const element = fixture('BasicRequired');
      element.value = ['test'];
      flush(() => {
        element._removeChip(0);
        const result = element.validate();
        assert.isFalse(result);
        done();
      });
    });

    test('Returns false when pattern do not match', (done) => {
      const element = fixture('Pattern');
      element.value = ['test'];
      flush(() => {
        element._value = 'test value';
        const result = element.validate();
        assert.isFalse(result);
        done();
      });
    });
  });

  suite('_autofocusChanged()', () => {
    test('Calls _autofocusChanged() when property change', (done) => {
      const element = fixture('Basic');
      flush(() => {
        const spy = sinon.spy(element, '_autofocusChanged');
        element.autofocus = true;
        assert.isTrue(spy.called);
        done();
      });
    });
  });

  suite('_findSource()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns undefine when no source', () => {
      const result = element._findSource();
      assert.isUndefined(result);
    });

    test('Returns undefine when source empty', () => {
      const result = element._findSource([]);
      assert.isUndefined(result);
    });

    test('Finds string item by value', () => {
      const result = element._findSource(['test'], 'test');
      assert.equal(result, 'test');
    });

    test('Ignores empty values', () => {
      const result = element._findSource(['', 'test'], 'test');
      assert.equal(result, 'test');
    });

    test('Ignores case of source', () => {
      const result = element._findSource(['', 'Test'], 'test');
      assert.equal(result, 'Test');
    });

    test('Returns undefined when not found', () => {
      const result = element._findSource(['Test'], 'other');
      assert.isUndefined(result);
    });

    test('Finds string item by id', () => {
      const result = element._findSource(['test'], '', 'test');
      assert.equal(result, 'test');
    });

    test('Finds object item by value', () => {
      const result = element._findSource([{value: 'test'}], 'test');
      assert.deepEqual(result, {value: 'test'});
    });

    test('Finds object item by id', () => {
      const result = element._findSource([{value: 'test', id: 'other'}], 'other', 'other');
      assert.deepEqual(result, {value: 'test', id: 'other'});
    });

    test('Returns undefined when not found in objects', () => {
      const result = element._findSource([{value: 'test', id: 'id'}], 'other', 'other');
      assert.isUndefined(result);
    });

    test('Returns undefined when not found in objects and no id', () => {
      const result = element._findSource([{value: 'test', id: 'id'}], 'other');
      assert.isUndefined(result);
    });
  });
  </script>
</body>
</html>
